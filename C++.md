C++
===

### [참고서적  :전문가를 위한 C++](https://m.hanbit.co.kr/store/books/book_view.html?p_code=B3215427289)  
  

<details>
<summary>  목차  </summary>
<div markdown="1">       

> 1. Part1 : 전문가를 향한 C++ 첫 걸음 (필기X)
> > 1. C++와 표준 라이브러리 초단기 속성 코스
> > 2. 스트링과 스트링 뷰 다루기
> > 3. 코딩 스타일
> 2. [Part2 : 전문가답게 C++ 소프트웨어 디자인하기](#part2)
> > 4. 전문가다운 C++ 프로그램 디자인
> > 5. 객체지향 디자인
> > 6. 재사용을 고려한 디자인
> 3. [Part3 : ](#part3)
> >  

</div>
</details>

***
# Part2
## 4. 전문가다운 C++ 프로그램 디자인 
</br>

### 4.1 프로그램 디자인의 정의  

프로그램 디자인이란 프로그램의 구현 계획을 정리한 것으로 문서 형태로 작성하며  
대부분 다음과 같이 크게 두 부분으로 구성

1. 프로그램을 구성하는 서브 시스템
- 인터페이스와 서브시스템 사이의 의존성, 시브시스템 사이의 데이터 흐름,   
  서브시스템에 대한 입출력, 기본 스레드 활용 모델
2. 서브시스템별 세부사항
- 클래스 구성, 클래스 계층도, 데이터 구조, 알고리즘, 개별 스레드 활용 모델, 에러 처리 방법  
  </br></br>

### 4.2 프로그램 디자인의 중요성  
코드를 작성하기 전에 공식적인 디자인 단계를 거치면 프로그램의 전반적인 구조를 제대로 구성할 수 있다.  
디자인 단계를 거치지 않으면 서브시스템 사이의 관계, 재사용 또는 공유 정보 가능성, 그리고 주어진 작업을  
처리하기 위한 가장 쉬운 방법 등을 놓치기 쉽다.  
</br></br>

### 4.3 C++에 적합한 디자인 방법(별 내용 없음)  
</br></br>

### 4.4 C++ 디자인에 관련된 두 가지 원칙  

1. 추상화  
어떤 종류의 대상들에 대해 그것이 가져야 할 핵심적인 특징들을 가지는 모델을 만드는 것으로  
내부 구현과 외부 인터페이스가 명확히 분리되어 있어 내부 구조를 모르더라도 사용에 지장이 없다.

2. 재사용  
기존 코드를 활용하는 것으로 cout로 화면에 출력하는 코드도 재사용한 것이다.  
화면에 데이터를 출력하는 코드를 직접 작성하지 않고, 기존의 cout를 사용  
C++에서는 코드를 범용적으로 만들 수 있도록 **템플릿**이라는 기능을 제공  
</br></br>

### 4.5 코드 재사용  
재사용할 코드를 만드는 형식
* 독립 함수 또는 클래스 : 자신 또는 동료가 작성한 코드는 대부분 이런 형태로 재사용
* 라이브러리 : 특정한 작업을 처리하는데 필요한 코드를 한데 묶은 것
* 프레임워크 : 디자인할 프로그램의 기반이 되는 코드를 모아둔 것
* > 프로그램은 라이브러리를 활용하고, 프레임워크에 맞게 작성한다.  
즉 라이브러리는 특정한 기능을 제공, 프레임워크는 프로그램의 디자인과 구조에 대한 토대를 제공.
* API : 특정한 기능을 수행하는 코드나 라이브러리에 대한 인터페이스
* > API와 라이브러리는 다른 것으로 라이브러리는 구현을 의미하고  
API는 라이브러리를 외부에 제공하기 위한 인터페이스

4장에서는 간결한 표현을 위해 재사용 가능한 코드를 모두 라이브러리라고 표현  
</br>

코드 재사용 전략  
재사용하려는 코드가 라이브러리든 프레임워크든 관계없이 공통적으로 고려할 사항이 몇 가지 있다.

<details>
<summary>  1. 기능과 제약사항 파악하기  </summary>
<div markdown="1">       

* 멀티스레드 프로그렘에서 사용해도 안전한지  
* 라이브러리를 사용하는 코드에 대해 특별히 컴파일러에 설정해야 할 사항이 있는지
* 초기화나 종료 시 반드시 수행할 작업이 있는지
* 의존하는 라이브러리가 있는지
* 클래스를 상속할 때 어떤 생성자를 호출해야 하고 어떤 가상 메서드를 오버라이드해야 하는지  
* 함수가 메모리 포인터를 리턴할 때 그 메모리를 해제하는 작업을 호출한 코드와 라이브러리 중 어느 쪽이  
책임져야 하는지 파악(라이브러리에서 처리시 메모리 해제 시점을 파악)
 * 라이브러리 호출할 때 어떤 에러 조건을 확인해야 하는지
 * 함수에서 리턴하는 값이나 레퍼런스
 * 함수에서 발생하는 익셉션

</div>
</details>

<details>
<summary>  2. 성능 파악하기  </summary>
<div markdown="1">       

* 보통 빅오 표기법을 사용해 성능을 표현
* 빅오 실행기간이 같더라도 실제 속도는 다를 수 있다.
* 입력 크기가 작은 경우 O(n^2)이 O(n log n)보다 더 나을 수 있다.  
그러므로 프로그램에서 다룰 입력 크기부터 가늠한 뒤 알고리즘을 선정
* 사용할 라이브러리 코드의 실행 빈도를 고려

</div>
</details>

<details>
<summary>  3. 플랫폼 제약사항 파악하기  </summary>
<div markdown="1">       
</div>
</details>

<details>
<summary>  4. 라이선스와 기술 지원 파악하기  </summary>
<div markdown="1">       
</div>
</details>

<details>
<summary>  5. 도움을 받을 수 있는 곳 파악하기  </summary>
<div markdown="1">       
</div>
</details>
</br>  

오픈소스 라이브러리 : 기능을 구현시 많은 도움이 됨(라이선스 문제가 있을 수 있음)  
C++ 표준 라이브러리 : 기능,성능,직교성 위주로 디자인한 것으로 활용시 얻을수 있는 효과가 상당함  
</br></br>

### 4.6 (SKIP)
</br></br>

### 4.7 요약
> 디자인 개념
> 1. 추상화
> > 인터페이스와 구현을 분리  
> > 디자인할 때 반드시 적용해야 함
> 2. 재사용
> > 라이브러리, 프레임워크등을 재사용뿐만 아니라 개념 및 디자인에 대한 재사용도 반드시 고려해야 한다.  
> > 코드는 최대한 재사용할 수 있게 만든다.

</br></br>

## 5. 객체지향 디자인  
</br>

### 5.1 절차형 사고방식
C언어와 같은 절차형 언어는 하나의 작업만 담당하는 프로시저라 부르는 작은 단위로 코드를 구성한다.  
* 프로시저 : 일종의 추상화 기법으로서 "이 프로그램이 무슨 일을 하는가?"라는 기본 질문을 바탕으로 발전된 개념이다.  

일정한 단계에 따라 진행하는 프로그램이라면 절차형 접근 방식이 적합  
하지만 대규모 애플리케이션에서는 여러 이벤트가 일정한 순서 없이 발생하고 사용자는 원하는 명령을 언제든지 수행 가능해야 함
</br></br>

### 5.2 객체지향 철학
절차형 접근 방식은 "이 프로그램이 무슨 일을 하는가?"라는 질문을 토대로 접근  
객체지향 접근 방식은 "현실세계의 어떤 대상을 모델링하는가?"
</br>  
객체지향 프로그래밍에서는 프로그램을 작업 단위가 아니라 물리적인 대상에 대한 모델 단위로 나눈다.  
 
1. 클레스  
어떤 대상의 유형을 정의하는 속성을 정리한 것으로  
객체란 어떤 클래스에 속하는 구체적인 인스턴스이다.  

2. 컴포넌트  
본질적으로 클래스와 같지만 클래스보다 작고 구체적이라는 점만 다르다.  
클래스를 여러 개의 작고 관리하기 쉬운 컴포넌트로 나누며, 이 나눈 컴포넌트 또한  
또 다른 컴포넌트를 가질 수 있다.  

3. 프로퍼티  
객체는 프로퍼티(속성)로 구분된다. 클레스 프로퍼티의 값은 그 클래스에 속한 모든 객체가 똑같이 가지지만  
객체 프로퍼티의 값은 그 클래스에 속한 객체마다 다를 수 있다.  
즉 프로퍼티는 객체의 특성을 표현한다. 다시말해 프로퍼티로 다른 객체와 구분할 수 있다.  

4. 동작  
객체가 하는 일 또는 그 객체로 할 수 있는 일을 표현한다.  
OOP에서는 어떤 기능을 수행하는 코드를 프로시저가 아닌 클래스 단위로 묶는다.  
여러가지 동작을 수행하는 클래스를 만들고 서로 상호작용하는 방식을 정의함으로써 데이터를 조작하는 코드를 횔씬 다양하게 제공할 수 있다.  
이러한 클래스의 동작은 클래스 메서드로 구현한다.  
</br></br>

### 5.3 객체 관점에서 바라보기
소프트웨어를 객체 관점으로 개발하는 데 적용할 수 있는 접근 방식은 크게 두 가지가 있다.  
1. 객체를 단순히 데이터와 기능을 잘 묶어주는 수단으로만 여기고 프로그램 전반에 걸쳐 사용해서 유지보수성을 높이는 것
2. OOP페러다임을 완벽히 적용해서 처음부터 모든 것을 객체로 표현하는 것

객체지향 시스템 설계시 주의해야 할 점
1. 과도한 객체화 : 객체로 만들 필요가 없는 사소한 것까지 객체로 만드는 경우
2. 지나친 일반화 : 객체를 과도하게 일반화하여 구체적인 대상을 표현하기 힘듬  
</br></br>

### 5.4 객체 관계
프로그래밍을 하다 보면 서로 다른 클래스가 공통적인 속성을 가지거나 최소 두 클래스가 서로 관련되는 경우가 있다.
객체지향 언어는 이런한 객체의 관계를 표현라기 위해 몇 가지 메커니즘을 지원하며
크게 has-a 관계와 is-a관계가 있다.

1. **has-a 관계(포함 관계,소유 관계, 집합 관계))**  
A는 B를 가진다 혹은 A에 B가 있다고 표현되는 객체 관계(한 객체가 다른 객체의 일부분)  

2. **is-a 관계(상속 관계)**  
is-a 관계는 OOP의 핵심 개념 중 하나인 상속에 대한 것으로 객체가 주로 계층 구조로 이루어졌다는 점을 모델링한 것이다.   
클래스를 is-a 관계로 엮으려면 공통 기능을 베이스 클래스(상위 클래스)로 묶어서 다른 클래스가 확장 수 있게 만들어야 한다.  
</br>
2-1 상속 기법  
파생 클래스를 부모 클래스와 구분하는 방법은 여러 가지가 있는데, 그중 한 개 혹은 여러 개의 기법을 조합해서 파생 클래스를 만든다.   
이러한 관계를 "A는 일종의 B로서..."라는 특성이 있다고 표현한다.  
| 기능 추가 : 파생 클래스는 기능을 더 추가해서 부모 클래스를 보완한다.  
| 기능 변경 : 파생 클래스는 부모 클래스가 가진 메서드를 변경하거나 무시(오버라이드)할 수 있다.  
| 프로퍼티 추가 : 베이스 클래스를 상속한 파생 클래스에 새로운 프로퍼티를 추가할 수 있다.  
| 프로퍼티 변경 : 메서드를 오버라이드하는 것처럼 프로퍼티도 오버라이드할 수 있다.(바람직하지 않을 때가 많다.)  
</br>
2-2 다형성과 코드 재사용  
다형성(폴리모피즘) : 프로퍼티와 메서드의 표준 셋으로 정해두면 그 형식에 맞는 객체라면 어느 것이든 서로 바꿔서 적용할 수 있다는 개념  

3. has-a관계와 is-a관계 구분하기  
두 관계를 구분하는 기준이 확실하지 않을 때가 많다. 따라서 구현할 클래스의 용도를 분석하고,  
기존 클래스에 있는 기능을 단순히 이용하기만 하는지 아니면 기존 기능을 변경하거나 새 기능을 추가하는지 확실히 파악해야 한다.  

4. not-a 관계  
두 클래스 관계 중 어느 것이 적합한지 따지기 전에 먼저 그런 관계가 설립할 수 있는지부터 살펴봐야 한다.  
객체지향 방식으로 계층을 구성하려면 억지로 관계를 형성하지 말고 기능 관점에서 관계를 표현해야 한다.  

5. 클래스 계층  
* 각 파생 클래스를 구현하다 보면 여러 가지 공통점을 발견할 수 있다. 이런 부분은 부모 클래스로 옮기는 게 좋다.  
* 현실세계에서 볼 수 있는 관계와 공통 기능 관점으로 분류한 관계 사이의 균형을 조절할 필요가 있다.
* 계층은 얼마든지 다르게 구성할 수 있다.
* 제대로 구현된 객체지향 계층은 다음과 같은 특성을 갖는다.
  * 기능적으로 의미 있는 관계에 따라 클래스를 구성한다.
  * 공통 기능을 베이스 클래스로 뽑아냈기 때문에 코드를 재사용하기 쉽다.
  * 부모가 추상 클래스가 아닌 이상 부모의 기능을 과도라게 오버라이딩하는 파생 클래스가 없다.  

6. 다중 상속  
다중 상속을 사용할 일이 많지 않지만 다중 상속이 꼭 필요한 경우가 있다. 하지만 단점도 존재한다.(가능하면 피하는 것이 좋음)  
    * 첫째. 다중 상속 관계는 시각적으로 표현하기 복잡하다.  
    * 둘째. 다중 상속 때문에 구조의 명확성이 깨질 수 있다.  
    * 셋째. 다중 상속은 구현하기 힘들다.  
</br>

7. 믹스인 클래스  
믹스인(첨가) 클래스 : is-a 관계를 완전히 구현하지 않고도 기능을 추가할 때 사용한다.(일종의 공유 관계)  
</br></br>

### 5.5 추상화  
1. 인터페이스와 구현  
추상화의 핵심은 인터페이스와 구현을 실질적으로 분리하는 데 있다.

2. 외부에 공개할 인터페이스 결정하기  
클래스를 디자인할 때는 다른 프로그래머가 이 클래스의 객체를 접근하는 방법도 정해야 한다.  
</br>
2-1 사용자 고려하기  
외부 인터페이스를 디자인할 때는 가장 먼저 사용할 사람을 분석  
2-2 용도 고려하기  
     * API  
       제품의 기능을 다양한 용도로 활용하거나 그 제품의 기능을 확장하기 위해 외부에 제공하는 인터페이스  
     * 유틸리티 클래스 또는 라이브러리  
       클래스나 라이브러리는 다양한 문맥에서 사용하기 때문에 활용 범위를 고려해서 디자인에 반영  
     * 서브시스템 인터페이스  
       핵심 목적을 분명히 하여 어떤 형태로 제공돼야 할지 결정
     * 컴포넌트 인터페이스  
       서브시스템, API보다 작은 인터페이스를 정의할 잉이 많다.  
       혼자서만 사용하더라도 남이 사용한다 생각하고 주 목적을 염두한체 이에 벗어난 기능을 외부에 노출하지 않도록 주의한다.  
</br>
3. 미래 고려하기  
인터페이스를 디자인할 때는 반드시 미래에 사용할 일도 고려해야 한다. 

***
# Part3



***
